* Blocurile întorc valoarea ultimei expresii.
* Funcțiile diferite de metode (ca în C++).
* return reprezintă o ieșire forțată dintr-o funcție **cu nume**.
** Nu trebuie folosit în alte situații.
* Parametrii combinați, fără nume și cu nume, cei fără fiind primii.
** Unii parametri pot avea valori default (ca în C++).
* Procedurile nu au egal, ci doar acolade.
* lazy val
* def este evaluat la fiecare folosire, val doar la definire (definirea poate
fi întârziată cu lazy).
* Expresiile if întorc tipul cel mai general dintre cele două ramuri.
** Dacă una din ramuri întoarce Nothing este ignorată.
* Expresiile throw întorc Nothing.
* Metodele fără parametri pot fi apelate fără (), dar cele care schimbă starea
obiectului ar trebui să includă parantezele.
* Implementarea de proprietăți în clase:
** var foo: getter și setter
** val foo: getter și valoare constantă
** private var privateFoo: getter (def foo) și setter (def foo_=(..)) creat manual
** private var privateFoo: getter (def foo) creat manual pentru proprietate read-only variabilă
* type projection <Class>#<InnerClass>
* Pentru colecția coll, coll: _* se expandează în mai mulți parametri pentru apelul unei funcții cu număr de parametri variabili.
* <EnclosingClass>.this (ca în Java)
* Redenumirea claselor la import
* Apelarea super constructorului direct din declarația clasei.
* Un def dintr-o clasă de bază poate fi override-at de un val în clasa moștenitoare.
* Anonymous subclasses
* Early definition (with)
* Ierarhia de clase: Any, AnyVal, AnyRef, Nothing, Null, ScalaObject
** Nothing nu are instanțe.
* eq este pentru obiecte în Scala ce este == în Java.
* trait-urile se înlănțuie (midex in) cu with, iar metodele suprascrise sunt apelate de la ultima din lanț la prima.
** super nu apelează un părinte, decât dacă se folosește notația super[părinte]
** super apelează trait-ul anterior lui din mixed in.
* Trait-urile pot conține metode abstracte, care pot fi override-ate cu abstract override.
* Initializing trait fields: early initialization după new la crearea unui obiectului.
* Se poate mixa un trait care extinde o clasă, caz în care clasa respectivă devine superclasa clasei care extinde trait-ul.
** Clasa care extinde trait-ul are posibilitatea să extindă și o altă clasă cu condiția ca aceasta să fie o subclasă a superclasei extinse de trait.
* Self types pentru trait-uri:
** Impun claselor care extind traitul să extindă o subclasă a self type-ului.
** Trait-ul cu self type nu extinde efectiv clasa self type.
* Self types în structural types
* Escape hatch: `reserved_keyword`
* An extended class argument will not be bound to a superclass field which has the same name.
* Operatorii unari au prioritate mai mare decât cei infix.
* Operatorii care se termină în : reprezintă metode ale celui de-al doilea argument și au asociativitate de dreapta.
* Un apply boolean poate testa o condiție într-un case class.
* implicit pentru converisia SAM (Single Abstract Methods) în funcții.
* Currying pentru inferență tipului parametrilor.
* Folosire call-by-name (în loc de call-by-value) pentru a crea control abstractions.
* O expresie return dintr-o funcție anonimă întoarce va face funcția cu nume care o conține să întoarcă.
* Stream-urile sunt leneșe și calculează valoarea doar când este apelat tail.
** Se poate folosi take cu force pe un stream pentru a forța un număr de valori.
* Când mai multe prelucrări funcționale sunt necesare pe o colecție înaintea primei funcții de prelucrare se poate folosi view, iar sfârșit force.
* În pattern matching dacă identificatorul de după case este scris cu litere mici atunci este interpretat ca variabilă nouă și face match la orice.
** Pentru a evita asta se înconjoară identificatorul cu backtick-uri `.
* În pattern matching când se face match pentru un tip trebuie precizat numele variabilei sau _, altfel se va face match pe obiect.
* Nu se poate face match pentru un anume tip generic A[X, Y], dar A[_, _] merge, la fel și Array[Int] de exemplu.
** pentru că nu există generice pentru JVM.
* Se poate folosi expandarea _* pentru a face match la număr de parametri variabili.
* Într-un for comprehension un match eșuat este ignorat.
* La un case sau într-un for comprehension se poate folosi un guard if.
* Clauze case cu notație infix
* Funcțiile parțiale nu sunt definite pe tot domeniul și pot verifica dacă o intrare e definită.
** collect din colecții privește o funcție parțială.
