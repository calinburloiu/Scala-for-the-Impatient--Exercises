* Blocurile întorc valoarea ultimei expresii.
* Funcțiile diferite de metode (ca în C++).
* return reprezintă o ieșire forțată dintr-o funcție **cu nume**.
** Nu trebuie folosit în alte situații.
* Parametrii combinați, fără nume și cu nume, cei fără fiind primii.
** Unii parametri pot avea valori default (ca în C++).
* Procedurile nu au egal, ci doar acolade.
* lazy val
* def este evaluat la fiecare folosire, val doar la definire (definirea poate
fi întârziată cu lazy).
* Expresiile if întorc tipul cel mai general dintre cele două ramuri.
** Dacă una din ramuri întoarce Nothing este ignorată.
* Expresiile throw întorc Nothing.
* Metodele fără parametri pot fi apelate fără (), dar cele care schimbă starea
obiectului ar trebui să includă parantezele.
* Implementarea de proprietăți în clase:
** var foo: getter și setter
** val foo: getter și valoare constantă
** private var privateFoo: getter (def foo) și setter (def foo_=(..)) creat manual
** private var privateFoo: getter (def foo) creat manual pentru proprietate read-only variabilă
* type projection <Class>#<InnerClass>
* Pentru colecția coll, coll: _* se expandează în mai mulți parametri pentru apelul unei funcții cu număr de parametri variabili.
* <EnclosingClass>.this (ca în Java)
* Redenumirea claselor la import
* Apelarea super constructorului direct din declarația clasei.
* Un def dintr-o clasă de bază poate fi override-at de un val în clasa moștenitoare.
* Anonymous subclasses
* Early definition (with)
* Ierarhia de clase: Any, AnyVal, AnyRef, Nothing, Null, ScalaObject
** Nothing nu are instanțe.
* eq este pentru obiecte în Scala ce este == în Java.
* trait-urile se înlănțuie (midex in) cu with, iar metodele suprascrise sunt apelate de la ultima din lanț la prima.
** super nu apelează un părinte, decât dacă se folosește notația super[părinte]
** super apelează trait-ul anterior lui din mixed in.
* Trait-urile pot conține metode abstracte, care pot fi override-ate cu abstract override.
* Initializing trait fields: early initialization după new la crearea unui obiectului.
* Se poate mixa un trait care extinde o clasă, caz în care clasa respectivă devine superclasa clasei care extinde trait-ul.
** Clasa care extinde trait-ul are posibilitatea să extindă și o altă clasă cu condiția ca aceasta să fie o subclasă a superclasei extinse de trait.
* Self types pentru trait-uri:
** Impun claselor care extind traitul să extindă o subclasă a self type-ului.
** Trait-ul cu self type nu extinde efectiv clasa self type.
* Self types în structural types
* Escape hatch: `reserved_keyword`
* An extended class argument will not be bound to a superclass field which has the same name.
* Operatorii unari au prioritate mai mare decât cei infix.
* Operatorii care se termină în : reprezintă metode ale celui de-al doilea argument și au asociativitate de dreapta.
* Un apply boolean poate testa o condiție într-un case class.
* implicit pentru converisia SAM (Single Abstract Methods) în funcții.
* Currying pentru inferență tipului parametrilor.
* Folosire call-by-name (în loc de call-by-value) pentru a crea control abstractions.
* O expresie return dintr-o funcție anonimă întoarce va face funcția cu nume care o conține să întoarcă.
* Stream-urile sunt leneșe și calculează valoarea doar când este apelat tail.
** Se poate folosi take cu force pe un stream pentru a forța un număr de valori.
* Când mai multe prelucrări funcționale sunt necesare pe o colecție înaintea primei funcții de prelucrare se poate folosi view, iar sfârșit force.
* În pattern matching dacă identificatorul de după case este scris cu litere mici atunci este interpretat ca variabilă nouă și face match la orice.
** Pentru a evita asta se înconjoară identificatorul cu backtick-uri `.
* În pattern matching când se face match pentru un tip trebuie precizat numele variabilei sau _, altfel se va face match pe obiect.
* Nu se poate face match pentru un anume tip generic A[X, Y], dar A[_, _] merge, la fel și Array[Int] de exemplu.
** pentru că nu există generice pentru JVM.
* Se poate folosi expandarea _* pentru a face match la număr de parametri variabili.
* Într-un for comprehension un match eșuat este ignorat.
* La un case sau într-un for comprehension se poate folosi un guard if.
* Clauze case cu notație infix
* Funcțiile parțiale nu sunt definite pe tot domeniul și pot verifica dacă o intrare e definită.
** collect din colecții primește o funcție parțială.
* Adnotarea constructorului primar se face înainte de parateza acestuia, iar adnotarea trebuie să aibă paranteze, chiar dacă nu are argumente.
** A nu se confunda cu adnotarea clasei.
* Expresiile pot fi adnotate: expr: @adnotare
* Parametri de tip și tipurile pot fi adnotate.
* Adnotările pot avea parametru de tip.
* Într-o funcție recursivă, ultimul pas al computației trebuie să fie o apelul recursiv pentru a permite compilatorului să aplice "tail recursion", transformare în buclă.
** Folsește @tailrec pentru a știi dacă e în stare compilatorul să aplice "tail recursion".
* Vezi trampolining (pg. 207)!!!
* Folosește @switch pentru expresii din match pentru a verifica dacă poate compilatorul să implementeze case-urile ca jump-uri.
* Când se dorește crearea unei metode numerice pentru toate tipurile primitive se poate adnota parametrul de tip cu @specialized .
** Adnotarea poate fi specializată, transmițând ca parametri ceea ce ne interesează.
* Numele parametrilor contează -- pot fi chemați după nume.
** Dacă se schimbă numele unui parametru, pentru a păstra compatibilitatea se folosește @deprecatedName('numeVechi) .
* Simbolurile (tipul Symbol) sunt un soi de șiruri de caractere garantate a fi unice dacă au același "nume". Operatorul == verifică referințe -- e eficient.
* Acolade pentru cod în XML.
* Acolade pentru code patterns când avem case-uri cu XML.
** case <z>{_}</z> // z cu un nod în el
** case <z>{_*}</z> // z cu secvență de noduri în el
** case <z>{child}</z> // child va fi un nod din z
** case <z>{children @ _*}</z> // children vor fi o secvență de noduri din z
* Operatorul % pentru adăugare / modificare atribut în Elem XML (elementul este imuabil, deci se crează unul nou)
* Transformări XML cu RuleTransformer care primește obiecte RewriteRule.
* Într-o colecție flatMap poate să filtreze obiecte Option, intorcând o colecție care conține doar acele elemente care au putut fi obținute prin get pe opțiune.
* O funcție anomică care acceptă mai mulți parametri poate fi transformată într-o funcție care acceptă un tuplu corespunzător parametrilor dacă se apelează tupled.
* Tipurile singleton <obj>.type pot avea ca instanțe obiectul respectiv sau null.
* Method chaining se poate realiza folosing this.type. În felul ăsta se pot face moșteniri.
* Clasele interne pot fi asemătoare celor statice din Java cu type projection.
* Alias de tip cu type. Poate fi abstract în clase abstracte ;-)
* Tipurile compure au forma T1 with T2 with ... with Tn { declarații }
* Aliasurile de tip pot fi generice, de ex.: type x[A, B] = (A, B)
* Tipurile parametrizate se pot înfrăți cu operatorii atunci când sunt în notație infix; de ex.: String Map Int same-same with Map[String, Int]
* Tipurile existanțiale (forSome) oferă flexibilitate în definirea tipurilor.
** Pot conține type și val.
** Sunt folosite pentru interoperabilitatea cu wildcard-urile Java.
** Wildcard-urile Scala sunt zăhărel sintactic pentru tipuri existențiale.
* Metodele și funcțiile au tipuri diferite: (x: Int)Int not same-same Int => Int
* Self type-urile nu se moștenesc automat.
* Cake pattern și dependency injection
* Tipuri parametrizate vs. Tipuri abstracte
* Higher-kinded types
* Se poate ca un parametru implicit să fie în același timp și conversie implicită.
** Se folosește des pentru conversie și parametru implicit T => Ordered[T].
* Funcția implicitly[T] din Predef întoarce o funcție implicită pentru un tipul parametru T.
* View bounds au nevoie de implicit conversion, context bound de implicit values.
